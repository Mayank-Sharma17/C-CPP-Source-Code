Here I will write some basic rules and important points to remember in C language :- QUICK REVISION
---------------------------------------------------------------------------------------------------

BASICS OF C :-
--------------

1. variable name kabhe bhe number is start nahe hoge or special character or keyword use nahe honge
   FLOAT, _Manu, M_anu, MAYANK ye sab valid hai 

2. float/int -> float float/float -> float int/float -> float int/int -> int (3/4 = 0)
   agar float - int kar rahe ho toh internally jo int var hai usee alag se float mae store krke result float mae dega *GIF [.] ques*
   Float -> sirf 6 decimal place tak accurate hai (0.123456) 

3. &x ->  address of variable x in scanf
    NOTE:- scanf is designed to skip any whitespace (spaces, tabs, newlines) before it reads each input — but not after.

           When you add a space at the end of the format string (like " %d %d "), it tells scanf to expect more input, because it’s waiting to match that whitespace with something — usually a non-whitespace character.
 
4. printf -> mae spaces bhe consider hote hai double quotes ke ander 

5. Modulo Operator
    2 % x = 2 ( x > 2 )
    a % b = a ( a < b )

    2 % -8 = 2

6. Hierarchy or operators:-
    B, O, %, D/M, A/S Left -> Right in /*

7. char data type (1 byte) .... %C, single digit -> 'a', 'ab' *wrong
    ASCII(American Standard Code for Information Interchange) -> 'A' = 65 'a' = 97

8. int vs short vs long (4 bytes vs 2 bytes vs 8 bytes) ..... kind of range of floating point representation* 
    n bits -> 2^n  numbers store kr skte ho
    short range -> -32768 to 32767 (-2^15 to 2^15-1)
    int range -> -2^31 to 2^31-1
    long long range -> -2^63 to 2^62-1
    float -> 4 byte Standard


IF/ESE :- (control statements/conditionals)
-------------------------------------------

1. If we want to to find the number div by 5 or 3 without using logical && then we can use nested if-else conditions

2. Hierarchy or operators:-
    && > || Ex: if( n%5==0 || n%3==0 && n%15!=0 )
                             |-----------------| ye code phele chalega due to higher preference that's why we use brakets () for correct output, then brackets will be executed first !              

3. if(condition) 
        printf("......")  If there is single statement to print then we can remove curly braces.

4. If there is only 2 conditions to check then if-else is sufficient.

5. agar if ke lader use kroge toh saare if conditions check hote hai, else if lader use krne par agar ek bhe condition hit kar gae toh next condition check nahe hoge.

6. TERNARY OPERATOR

    exp1 ? exp2 : exp3 --> condition ? if true : else false
    Ex: n%2==0 ? printf("Even number") : printf("Odd number") ; (rewrite if-else in 1 line)

7. Type Promotion/ Conversion :-

    int a = 3;
    float b = 2.5;
    float result = a + b; // 'a' is promoted to float here

    if (a == b) // a is int, b is float
    a is promoted to float for the comparison. (Implicit Conversion)

8. Boolean Datatype :-
    bool x --> ture/false --> 1/0

NOTE : In C, assignment operators always associate from right to left.

        a = (b = (c = 5));

        c = 5 → assigns 5 to c, returns 5.

        b = 5 → assigns 5 to b, returns 5.

        a = 5 → assigns 5 to a.


LOOPS :- (for, while, do while) DRY -> DO NOT REPEAT YOURSELF
-------------------------------------------------------------

1. FOR LOOP :-
    for(initialization; condition; increment/decrement){
        // code
    };
    i++ --> i=i+1
    i+=2 --> i=i+2

2. BREAK & CONTINUE STATEMENT :-
    prime&composite no --> use of 'break' :- It is used to terminate the loop.

    use of 'continue' :- It is used to skip that particular iteration of the loop. (update - i++)

3. WHILE LOOP :- Best for Unknown Iteration Count
    initialization
    while(condition) { // jab hamne jyada cheeze na pata ho tab use kro 
        updation
    }

   int j; // by default j ke ander garbage value hote hai/ random value 

4. post/pre increment :-
    x++ --> post increment --> use x, then increment
    ++x --> pre increment --> first increment, then use x

    int x = 4, y, z; -----> 4 _ _
    y = --x; // 3 3 _
    z = x--; // 2 3 3

5. DO-WHILE LOOP :- // ek baar to chalega he chalega irrespective of the condition.
    do {
        //code
    } while(condition);
 
6. TYPECASTING :-
    int x = 65;
    printf("%d", x); // output - 65
    char ch = (char)x; // this is typecasting
    printf("%c", ch); // output - A

7. NOTE: The pow() function returns a double. In C, the function pow(base, exponent) returns a double, which is a floating-point number.   Due to the inherent inaccuracy of floating-point math.
    Floating-point truncation --> 152.999 becomes 152 if directly cast


PATTERS :- 
----------------------------------------------------------------------------------------------------------------------------------------

1. Check no. of lines
2. In each line what is happening (check how many times a pattern or number we have to print)
3. then use maths and check the relation between the input number and the row and col (n, i, j), use extra var if needed
4. figur it out !

FUNCTIONS & POINTERS :-
------------------------

1. Helps to avoid repititive code.
2. It helps use to implement functional programming.
3. Improves code reusability
4. PASS BY VALUE & PASS BY REFERENCE :- 
    When we swap two numbers inside the main function, it works easily because we directly change the variables.

    But when we pass these two numbers to a function using pass by value, the function only receives copies of those variables — not the actual variables themselves.
    So any change inside that function affects only the copies, not the original values in main().

    That’s why, to actually swap the original numbers, we use pass by reference (in C, this is done using pointers *).
    By passing the addresses of the variables, the function can directly modify their values in memory.

5. FORMAL PARAMETERS AND ACTUAL PARAMETERS :-
    In main function swap(a, b); calling a function in which a and b for formal parameters and their value is actual parameters.

6. POINTERS* 
    %p --> we can print address (printf("%d", &a))
    With the help of pointers we can actually change the value of the variable whose address is stored in the pointer itself
    swap(&a, &b) --> pass by reference we are passing addresses instead of values.

RECURSION :-
---------------------------------------------------

Function calling itself

Recursion is a technique where a function calls itself to solve a problem.

A recursive solution breaks a big problem into smaller subproblems of the same type.

Every recursive function must have:
    Base Case → the condition where the recursion stops.
    Recursive Case → the part where the function calls itself.

Without a base case, recursion leads to infinite calls and stack overflow.

Recursion is useful for problems like:
    factorial, Fibonacci
    tree/graph traversal
    divide & conquer algorithms (merge sort, quick sort)

Often simpler to write but may use more memory than iterative solutions because of the call stack.

function factorial(n):
    if n == 0:          // Base case
        return 1
    else:
        return n * factorial(n - 1)   // Recursive case

ARRAYS :- 1D & 2D
-----------------

1. Collection of objects of similar data types.
2. 0 based indexing.
3. continous memory allocation. (but in normal address allocation of the variable it will randomly allocate memory there is not relation in that)
4. index out of bound error --> if you access the wrong index or more than the size of the array
5. num[n] --> we got (n+1)th element 
6. Garbage Values --> in we didn't initialize variables and arrays in C, there will be some garbage value sotred in it.
7. *PASSING ARRAY IN A FUNCTION --> if we pass an array as an argument in a function it will be passed by reference. (in all c, cpp, java)
8. Address of the array is the address of the first element of the array.
9. *Reverse the array --> 2 var/pointers i=0 and j=arrysize and then swap i and j till i<j

10. #include<limits.h> --> to use min and max number --> INT_MIN & INT_MAX 

10. 2D ARRAY --> GRID/MATRIX

STRINGS :-
---------------------

1. character arrays
2. char take 1 byte of storage 
3. ASCII values --> 'A' - 65  'a' - 97
                    '0' - 48  '9' - 57
4. NULL CHARACTER --> \0  and its ascii value is 0 (zero), and it can't be printed like other chars but it still exist.
5. char str[] = "Mayank Sharma" -->  computer end mae \0 laga deta hai jab vo char array mae store hota hai.
   char str[] = {'H', 'e','l','l','o'}; isme nahe krta, tumhe khud end mae '\0' lagana padega if you don't want to calculate size
   char str[10] = "MCA" --> storage wastage hai but fir bhe chalega 

6. Initializing string without size --> char arr[] = "Mayank" size of this string is 7 --> 6 char + 1 '\0'

7. str[i] = i[str] = *(str + i) = *(i + str) sab same hai

8. built in c functions --> #include<string.h>
                            char str[] = "manu";
                            printf("%s", str); 
                            puts(str); // this will print the same str
   puts("Hello this puts consider everything inside double quotes as a string"); 

   NOTE : puts() --> automatically \n dedeta hai (next line)

9. Input/Output in Strings :- gets() and puts()
    scanf("%[^\n]s", str); // only the first word will be considered --> %[^\n]s this will work for entire sentence

    taking using using gets()
    gets(str); // entire sentence can be input

NOTE :- kise bhe character array ka, array ka, string ka address uske phele ke 0th index ke element ka address hota hai!
        ptr --> stands for address, *ptr --> value/char fetch krskte hai

10. we get another way of initilizing strings
    character's pointer can also be used to store address of a string
    NOTE :- such direct initlization using pointers result in a read-only memory allocation of character arrays and hence, causes undefined behaviour when we try to change the individual characters.
    
    char *ptr = "programming";

    memory ----> programming
                 |
                 ^
                ptr (no name of the string in the memory but it is pointing to only first char of the string)   
                        
    printf("%s", ptr); // working
    ptr[0] = 'm' // ERROR!

    char str[] = "programming";
    printf("%s", ptr); // working
    str = "coding"; // ERROR!

    In normal initilization, we can modify individual characters but not the entire string.
    In pointer initialization, we can modify the entire string but not the individual characters.


STRUCTURES :-
------------------------------------------------------

1. user defined datatype.
2. collection of values(multiple attributes) of different data types.
3. saves use from creating too many variables
4. structure call by value se function mae pass hote hai

typedef -> keyword in C is used to create an alias or synonym for an existing data type, simplifying complex declarations and improving code readability.
 It allows programmers to define new names for existing types, such as int, struct, union, or pointers, making the code more descriptive and easier to maintain.
 For example, typedef int Integer; creates an alias Integer for int, so variables can be declared as Integer a, b; instead of int a, b;.
 It is especially useful with structures and pointers; for instance, typedef struct { int data; } Node; allows declaring Node n; instead of struct { int data; }

NOTE: remaining topics is covered with hands on pratice in the folders DMA and C_Practical and LAB.